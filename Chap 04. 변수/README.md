# Chap 04. 변수

**4장의 키워드**

> 변수, 식별자, 메모리, 변수 선언, 변수 할당, 호이스팅, 가비지 컬렉터

<br/>

## 메모리

-   **메모리(memory)**
    -   데이터를 저장할 수 있는 <u>메모리 셀의 집합체</u>
-   **메모리 셀(memory cell)**
    -   메모리 셀 하나의 크기는 1바이트(8비트) 단위로, 컴퓨터는 메모리 셀의 단위로 데이터를 write/read 한다.
    -   각 셀은 고유의 메모리 주소를 갖는다.
-   **메모리 주소(memory address)**
    -   메모리 공간의 위치

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용하여 데이터를 기억한다.  
컴퓨터는 모든 데이터를 **2진수로 처리**하기 때문에, 메모리에 저장되는 데이터는 종류에 상관 없이 2진수로 저장된다.

![image](https://github.com/dooli1971039/Modern-JS-Deep-Dive-Study/assets/70802352/5cdd1c35-bcb4-43a5-9624-8c313b69769e)

연산 결과를 재사용 하기 위해서는 <u>메모리 공간 접근</u>이 필요하다.  
하지만 메모리 공간에 "직접" 접근하는 것은 매우 위험하여 JS에서는 이를 허용하지 않는다.  
+) 값이 저장될 메모리 주소는 매 코드 실행마다 임의로 정해진다.

=> 그래서 **변수**가 필요하다

<br/>

## 변수

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

변수는 값의 위치를 가리키는 상징적인 이름으로, **인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행**된다. 이로써 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요 없이 값에 안전히 접근할 수 있다.

![image](https://github.com/dooli1971039/Modern-JS-Deep-Dive-Study/assets/70802352/104624c2-3ad7-4918-9cde-7ed32938aac2)

```js
var result = 10 + 20;
// 30(변수값)을 result(변수 이름)에 할당(대입,저장)하는 것
```

<br/>

## 식별자 (Identifier)

어떤 값을 구별해서 식별할 수 있는 고유한 이름으로, 값이 아니라 **메모리 주소를 기억**한다.

```
값은 메모리 공간에 저장되어 있고, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해야 한다.
=> 식별자는 어떤 값이 저장되어 있는 메모리 주소를 저장해야 한다.
```

==> 식별자는 **메모리 주소에 붙인 이름**이다.

-   변수, 함수, 클래스 등의 "이름"은 모두 식별자이다.
-   식별자는 "선언"에 의해 자바스크립트 엔진에 존재를 알린다.
-   식별자는 아래의 네이밍 규칙을 준수해야만 한다.
    ```
    1. 식별자는 특수문자를 제외한 문자, 숫자, 언더바, 달러 기호를 포함할 수 있다.
    2. 단, 숫자로 시작할 수는 없다.
    3. 예약어는 식별자로 사용할 수 없다.
       (식별자로 사용가능 하나, strict mode에서는 사용 불가능 한 것들도 있다.)
    ```
    -   JS는 대소문자를 구분하므로, 식별자 생성시 유의해야 한다.
    -   ES5부터 식별자를 만들 때 유니코드 문자를 허용하여, 알파벳 이외의 한글이나 일본어 식별자도 사용할 수 있다. (바람직하지는 않다)

### 네이밍 컨벤션

JS에서는 변수, 함수 이름에는 주로 **카멜 케이스**를 사용하며, 생성자 함수, 클래스 이름에는 **파스칼 케이스**를 사용한다.

```js
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

<br/>

## 변수 선언

변수 선언(variable declaration)은 변수를 "생성"하는 것으로, 아래 과정을 거친다.

```
1. 값을 저장하기 위한 메모리 공간 확보 (allocate)
2. 변수 이름과 확보된 메모리 공간의 주소 연결 (name binding)
```

변수를 사용하려면 반드시 **선언**이 필요한데, 이때 **var**, **let**, **const** 키워드를 사용한다.

<details>
<summary>var과 let의 차이</summary>

var과 let은 모두 변수를 선언한다.  
var는 블록 레벨 스코프를 지원하지 않고, 함수 레벨의 스코프를 지원한다. 같은 키워드로 재선언되어도 에러를 띄우지 않는다. let은 이러한 var의 단점을 보완하기 위해 es6에서 추가되었다.

</details>

<details>
<summary>키워드란?</summary>

자바스크립트 코드를 해석하고 실행하는 JS 엔진이 수행할 동작을 규정한 일종의 명령이다.  
var 키워드의 경우, var 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.

</details>
<br/>
<br/>

```js
var score; //변수 선언
```

-   var 키워드로 변수를 선언하면, 메모리 공간이 확보되고, 해당 공간과 변수 이름이 연결된다.
-   이때, 확보된 메모리 공간에는 `undefined`가 암묵적으로 할당되어 초기화 된다.  
     초기화를 안 한 채로 사용할 경우, 해당 메모리에 존재하던 쓰레기 값이 참조될 수 있다. JS가 undefined를 변수 선언 시에 넣는 것은, 쓰레기 값 참조를 막는 방법이다.
-   변수를 사용하려면 반드시 선언이 필요하다.  
     선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

<br/>

## 값의 할당

```js
var score = 80;
```

JS 엔진은 위의 코드를 아래와 같이 2개의 문으로 쪼개어 실행한다.

```js
var score; //변수 선언 -  undefined 값이 들어가게 됨
score = 80; // 값의 할당 -  이때 80이라는 값을 가지게 됨
```

다만, 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간에 새로운 값을 넣는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 된 값을 저장한다. (재할당도 동일함)

![image](https://github.com/dooli1971039/Modern-JS-Deep-Dive-Study/assets/70802352/2b35b1da-e08f-4fab-81fa-a5d1cf472faa)
어떠한 식별자와도 연결 되지 않는 값은, 앞으로 아무도 사용하지 않는 필요 없는 값이다. 이러한 불필요한 값은 가비지 콜렉터에 의해 자동 해제된다. (시기는 알 수 없음)

<details>
<summary>가비지 콜렉터</summary>

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여, 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란, 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. JS는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서, 가비지 콜렉터를 통해 메모리 누수를 방지한다.

**언매니지드 언어**

개발자가 명시적으로 메모리를 할당하고 해제할 수 있도록, 메모리 제어 기능을 제공한다.

ex) C언어 (malloc(), free())

**매니지드 언어**

메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 **개발자의 직접적인 메모리 제어를 허용하지 않는다.**  
ex) Javascript

</details>

<br/>

## 호이스팅

변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 **"런타임" 이전에 먼저 실행**된다.

```js
console.log(score); // undefined
var score; //변수 선언문
```

따라서 위와 같은 코드의 경우, ReferenceError가 아니라 undefined가 출력된다.  
(undefined이 이유는 JS가 기본적으로 변수 선언 시 undefined를 넣기 때문)

```
JS 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서, 먼저 소스코드의 평과 과정을 거치며 실행을 위한 준비를 한다.
이때 JS엔진은 "선언문"(변수 선언문, 함수 선언문, etc)을 소스코드에서 모두 찾아내어 먼저 실행한다.
소스코드의 평과 과정이 끝나면, 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
```

<br/>

```js
console.log(score); // undefined
var score = 80; // 변수 선언과 값의 할당
console.log(score); // 80
```

JS 엔진은 변수 선언과 값의 할당을 나누어 실행하므로, 위와 같은 결과가 나온다.

<br/>

```js
console.log(score); // undefined
score = 80; // 값의 할당 - 런타임에 실행
var score; // 변수 선언 - 런타임 "이전"에 실행 (호이스팅)
console.log(score); // 80
```

위 코드는 호이스팅 성질로 인해, 이상하게 보이지만 에러 없이 잘 작동 된다.
